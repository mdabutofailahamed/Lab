8.Write a C program to create a main process named ‘parent_process’ having ‘n’ child processes without any grandchildren processes. Child Processes’ names are child_1, child_2, child_3,......., child_n. Trace the position in the process tree. Number of child processes (n) and name of child processes will be given in the CLI of Linux based systems.
Example:
$ ./parent_process 3 child_1 child_2 child_3
Hint: fork, exec, fopen, system
-----------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main(int argc, char *argv[]) {
    if (argc < 3) {
        printf("Usage: %s <number_of_children> <child_name_1> <child_name_2> ... <child_name_n>\n", argv[0]);
        return 1;
    }

    int n = atoi(argv[1]); // Convert the first argument to an integer for the number of children

    // Check if the number of child processes matches the count of names provided
    if (argc != n + 2) {
        printf("Error: Number of child process names provided does not match the specified count.\n");
        return 1;
    }

    printf("Parent process (PID: %d) started.\n", getpid());

    for (int i = 0; i < n; i++) {
        pid_t pid = fork(); // Create a new process

        if (pid < 0) {
            perror("fork failed");
            exit(EXIT_FAILURE);
        } else if (pid == 0) { // Child process
            printf("Child process %s (PID: %d, Parent PID: %d) started.\n", argv[i + 2], getpid(), getppid());
            
            // The child process can perform its own task here or simply terminate.
            // For this implementation, we're not using exec since the children are not running different programs.
            
            // For example, the child can use sleep to simulate some work:
            sleep(2); // Simulate some work with sleep
            
            printf("Child process %s (PID: %d) is terminating.\n", argv[i + 2], getpid());
            exit(0); // Terminate the child process
        } else {
            // Parent process continues to the next iteration
            // Optionally, we can wait for each child to terminate (synchronously):
            wait(NULL);
        }
    }

    // If waiting for all children to finish, use this loop:
    for (int i = 0; i < n; i++) {
        wait(NULL); // Wait for all child processes to complete
    }

    printf("Parent process (PID: %d) terminating.\n", getpid());
    return 0;
}

-------------------------------------------------------------------------------------------------------------


9.Write a C program for creating a multi-threaded process and check: 
A.If one thread in the process calls fork() , does the new process duplicate all threads, or is the new process single-threaded? 
B.If a thread invokes the exec() system call, does it replace the entire code of the process?
C.If exec() is called immediately after forking, will all threads be duplicated?
----------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/wait.h>
#include <string.h>

// Function executed by each thread
void *thread_function(void *arg) {
    printf("Thread %ld started (PID: %d)\n", (long)arg, getpid());
    sleep(2); // Simulate work

    if ((long)arg == 1) { // Let the first thread call fork()
        printf("Thread %ld calling fork()...\n", (long)arg);
        pid_t pid = fork();

        if (pid < 0) {
            perror("fork failed");
            pthread_exit(NULL);
        } else if (pid == 0) { // Child process
            printf("In child process after fork (PID: %d, Parent PID: %d)\n", getpid(), getppid());

            // Uncomment the line below to test exec() behavior immediately after fork()
            // execlp("/bin/ls", "ls", NULL);

            sleep(1); // Simulate work in child
            printf("Child process terminating (PID: %d)\n", getpid());
            exit(0);
        } else {
            // Parent process waits for child to complete
            wait(NULL);
        }
    }

    // Let one thread call exec()
    if ((long)arg == 2) {
        printf("Thread %ld calling exec()...\n", (long)arg);
        execlp("/bin/echo", "echo", "Hello from exec!", NULL);
        // If exec succeeds, this line will not be printed
        perror("exec failed");
        pthread_exit(NULL);
    }

    printf("Thread %ld terminating (PID: %d)\n", (long)arg, getpid());
    pthread_exit(NULL);
}

int main() {
    pthread_t threads[3];
    printf("Main process started (PID: %d)\n", getpid());

    // Create multiple threads
    for (long i = 0; i < 3; i++) {
        if (pthread_create(&threads[i], NULL, thread_function, (void *)i) != 0) {
            perror("Failed to create thread");
            exit(1);
        }
    }

    // Wait for all threads to complete
    for (int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Main process terminating (PID: %d)\n", getpid());
    return 0;
}
----------------------------------------------------------------------------
10.Write a C program to show how two threads can communicate by the help of ‘signal’.
-----------------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>

// Global variable to indicate the completion of the task
volatile sig_atomic_t task_done = 0;
pthread_t thread1, thread2;

// Signal handler function
void signal_handler(int signo) {
    if (signo == SIGUSR1) {
        printf("[Thread 2] Received SIGUSR1: Task completed signal from Thread 1.\n");
        task_done = 1; // Mark the task as done
    }
}

// Thread function for Thread 1
void *thread_func1(void *arg) {
    printf("[Thread 1] Starting task...\n");
    sleep(2); // Simulate some work

    // Send signal to thread2 to indicate task completion
    printf("[Thread 1] Task completed. Sending signal to Thread 2.\n");
    pthread_kill(thread2, SIGUSR1);

    pthread_exit(NULL);
}

// Thread function for Thread 2
void *thread_func2(void *arg) {
    // Set up signal handler for SIGUSR1
    signal(SIGUSR1, signal_handler);

    printf("[Thread 2] Waiting for signal from Thread 1...\n");
    // Busy wait loop, waiting for the task to complete
    while (!task_done) {
        sleep(1); // Check periodically to avoid busy waiting
    }
    printf("[Thread 2] Notified of task completion. Proceeding with next steps.\n");

    pthread_exit(NULL);
}

int main() {
    // Create Thread 2
    if (pthread_create(&thread2, NULL, thread_func2, NULL) != 0) {
        perror("Failed to create Thread 2");
        exit(1);
    }

    // Create Thread 1
    if (pthread_create(&thread1, NULL, thread_func1, NULL) != 0) {
        perror("Failed to create Thread 1");
        exit(1);
    }

    // Wait for both threads to complete
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    printf("Main process exiting.\n");
    return 0;
}
---------------------------------------------------------------------------------------------
11.Write a C program to show how data inconsistency arises in a multi-threaded process.
----------------------------------------------------------------------------------------------



/*

	Write a C program to show how data inconsistency arises in a multi-threaded process.

*/


#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>


//int x = 10;

int balance = 500;

void thread1_controller(){
	
	balance = balance - 200;
	printf("Withdrawn 200 tk, new balance %d tk\n", balance);

	/*int temp = x;
	printf("Thread-1 :: temp = %d || current X = %d\n",temp,x);

	temp = temp + 1;
	printf("Thread-1 :: temp = %d || current X = %d\n",temp,x);

	x = temp;
	printf("Thread-1 :: temp = %d || current X = %d\n",temp,x);*/
}

void thread2_controller(){

	balance = balance - 350;
	printf("Withdrawn 350 tk, new balance %d tk\n", balance);

	/*int temp = x;
	printf("Thread-2 :: temp = %d || current X = %d\n",temp,x);

	printf("Thread-2 :: temp = %d || current X = %d\n",temp,x);
	temp = temp - 1;

	printf("Thread-2 :: temp = %d || current X = %d\n",temp,x);
	x = temp;*/
}


int main(){

	pthread_t thread1, thread2;
	
	pthread_create(&thread1, NULL, (void*)thread1_controller, NULL);
	pthread_create(&thread2, NULL, (void*)thread2_controller, NULL);
	
	
	pthread_join(thread1, NULL);
	pthread_join(thread2, NULL);

	//sleep(5);

	//printf("Final X : %d\n",x);
}
--------------------------------------------
or
--------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>

#define NUM_ITERATIONS 1000000

int counter = 0; // Shared resource

// Function executed by each thread
void *increment_counter(void *arg) {
    for (int i = 0; i < NUM_ITERATIONS; i++) {
        counter++; // Critical section
    }
    pthread_exit(NULL);
}

int main() {
    pthread_t thread1, thread2;

    // Create two threads that will increment the shared counter
    if (pthread_create(&thread1, NULL, increment_counter, NULL) != 0) {
        perror("Failed to create thread 1");
        exit(1);
    }
    if (pthread_create(&thread2, NULL, increment_counter, NULL) != 0) {
        perror("Failed to create thread 2");
        exit(1);
    }

    // Wait for both threads to complete
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);

    // Expected result: 2 * NUM_ITERATIONS
    printf("Final counter value: %d (Expected: %d)\n", counter, 2 * NUM_ITERATIONS);

    return 0;
}
----------------------------------------------------------------------------------------------
12.Write a multithreaded program that calculates various statistical values for a list of numbers. This program will be passed a series of numbers on the command line and will then create three separate worker threads. One thread will determine the average of the numbers, the second will determine the maximum value, and the third will determine the minimum value. For example, suppose your program is passed the integers
90 81 78 95 79 72 85
The program will report
A. The average value is 82
B. The minimum value is 72
C. The maximum value is 95
The variables representing the average, minimum, and maximum values will be stored globally. The worker threads will set these values, and the parent thread will output the values once the workers have exited.
----------------------------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Global variables to store the results
double average;
int minimum;
int maximum;
int count;
int numbers[100]; // Assuming maximum 100 numbers

// Function to calculate the average
void *calculate_average(void *arg) {
    double sum = 0.0;
    for (int i = 0; i < count; i++) {
        sum += numbers[i];
    }
    average = sum / count;
    pthread_exit(0);
}

// Function to find the minimum value
void *calculate_minimum(void *arg) {
    minimum = numbers[0];
    for (int i = 1; i < count; i++) {
        if (numbers[i] < minimum) {
            minimum = numbers[i];
        }
    }
    pthread_exit(0);
}

// Function to find the maximum value
void *calculate_maximum(void *arg) {
    maximum = numbers[0];
    for (int i = 1; i < count; i++) {
        if (numbers[i] > maximum) {
            maximum = numbers[i];
        }
    }
    pthread_exit(0);
}

int main(int argc, char *argv[]) {
    // Check if the user has provided numbers
    if (argc < 2) {
        printf("Usage: %s <list of integers>\n", argv[0]);
        return 1;
    }

    // Read numbers from the command line
    count = argc - 1;
    for (int i = 0; i < count; i++) {
        numbers[i] = atoi(argv[i + 1]);
    }

    // Create three threads
    pthread_t thread1, thread2, thread3;

    pthread_create(&thread1, NULL, calculate_average, NULL);
    pthread_create(&thread2, NULL, calculate_minimum, NULL);
    pthread_create(&thread3, NULL, calculate_maximum, NULL);

    // Wait for the threads to finish
    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    pthread_join(thread3, NULL);

    // Print the results
    printf("A. The average value is %.2f\n", average);
    printf("B. The minimum value is %d\n", minimum);
    printf("C. The maximum value is %d\n", maximum);

    return 0;
}
----------------------------------------------------------------------------------------------------------
13.The Fibonacci sequence is the series of numbers 0, 1, 1, 2, 3, 5, 8, .... 
Formally, it can be expressed as:
fib0 = 0
fib1 = 1
fibn = fibn−1 + fibn−2
Write a multithreaded program that generates the Fibonacci sequence. This program should work as follows: On the command line, the user will enter the number of Fibonacci numbers that the program is to generate. The program will then create a separate thread that will generate the Fibonacci numbers, placing the sequence in data that can be shared by the threads (an array is probably the most convenient data structure). When the thread finishes execution, the parent thread will output the sequence generated by the child thread. Because the parent thread cannot begin outputting the Fibonacci sequence until the child thread finishes, the parent thread will have to wait for the child thread to finish.
---------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

// Global variables
int *fibonacci_sequence; // Array to store the Fibonacci sequence
int n; // Number of Fibonacci numbers to generate

// Thread function to generate the Fibonacci sequence
void *generate_fibonacci(void *arg) {
    // Base cases
    if (n > 0) fibonacci_sequence[0] = 0;
    if (n > 1) fibonacci_sequence[1] = 1;

    // Generate the Fibonacci sequence
    for (int i = 2; i < n; i++) {
        fibonacci_sequence[i] = fibonacci_sequence[i - 1] + fibonacci_sequence[i - 2];
    }

    pthread_exit(0);
}

int main(int argc, char *argv[]) {
    // Check if the user has provided the number of Fibonacci numbers
    if (argc != 2) {
        printf("Usage: %s <number of Fibonacci numbers>\n", argv[0]);
        return 1;
    }

    // Convert the command line argument to an integer
    n = atoi(argv[1]);
    if (n <= 0) {
        printf("Please enter a positive integer.\n");
        return 1;
    }

    // Allocate memory for the Fibonacci sequence
    fibonacci_sequence = (int *)malloc(n * sizeof(int));
    if (fibonacci_sequence == NULL) {
        perror("Unable to allocate memory");
        return 1;
    }

    // Create a thread to generate the Fibonacci sequence
    pthread_t fibonacci_thread;
    pthread_create(&fibonacci_thread, NULL, generate_fibonacci, NULL);

    // Wait for the thread to finish
    pthread_join(fibonacci_thread, NULL);

    // Output the Fibonacci sequence
    printf("Fibonacci sequence: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", fibonacci_sequence[i]);
    }
    printf("\n");

    // Free the allocated memory
    free(fibonacci_sequence);

    return 0;
}
-------------------------------------------------------------------------------------------------
14.Implement a server-client model to provide services to client processes running in machines different from the server processes. Explain what you experience when you:
Server process being a single threaded process tries to provide services to multiple client processes.
Server process being a multi-threaded process tries to provide services to multiple client processes.
Server process being a single threaded process tries to provide services to multiple client processes with multiple child processes.
---------------------------------------------------------------------------------------------------------
single_threaded_server.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    char buffer[BUFFER_SIZE] = {0};

    // Create socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == 0) {
        perror("Socket failed");
        exit(EXIT_FAILURE);
    }

    // Bind to port
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);
    if (bind(server_fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
        perror("Bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Listen for connections
    listen(server_fd, 3);

    printf("Server is listening on port %d...\n", PORT);

    while (1) {
        // Accept a new connection
        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen);
        if (new_socket < 0) {
            perror("Accept failed");
            continue;
        }

        // Read message from client
        int bytes_read = read(new_socket, buffer, BUFFER_SIZE);
        printf("Received: %s\n", buffer);

        // Echo message back to client
        send(new_socket, buffer, bytes_read, 0);

        // Close the connection
        close(new_socket);
    }

    close(server_fd);
    return 0;
}


----------
client.c
---------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int sock = 0;
    struct sockaddr_in serv_addr;
    char buffer[BUFFER_SIZE] = {0};

    // Create socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        printf("\nSocket creation error\n");
        return -1;
    }

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(PORT);

    // Convert IPv4 and IPv6 addresses from text to binary form
    if (inet_pton(AF_INET, "127.0.0.1", &serv_addr.sin_addr) <= 0) {
        printf("\nInvalid address/ Address not supported\n");
        return -1;
    }

    // Connect to server
    if (connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr)) < 0) {
        printf("\nConnection Failed\n");
        return -1;
    }

    // Send message to server
    char *message = "Hello from client!";
    send(sock, message, strlen(message), 0);
    printf("Message sent: %s\n", message);

    // Read response from server
    int bytes_read = read(sock, buffer, BUFFER_SIZE);
    printf("Received from server: %s\n", buffer);

    close(sock);
    return 0;
}
---------------
multi_threaded_server.c
------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

void *handle_client(void *arg) {
    int new_socket = *(int *)arg;
    char buffer[BUFFER_SIZE] = {0};
    free(arg);

    // Read message from client
    int bytes_read = read(new_socket, buffer, BUFFER_SIZE);
    printf("Received: %s\n", buffer);

    // Echo message back to client
    send(new_socket, buffer, bytes_read, 0);

    // Close the connection
    close(new_socket);
    return NULL;
}

int main() {
    int server_fd;
    struct sockaddr_in address;
    int addrlen = sizeof(address);

    // Create socket
    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == 0) {
        perror("Socket failed");
        exit(EXIT_FAILURE);
    }

    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    // Bind to port
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 3);

    printf("Multi-threaded server is listening on port %d...\n", PORT);

    while (1) {
        // Accept a new connection
        int *new_socket = malloc(sizeof(int));
        *new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen);
        if (*new_socket < 0) {
            perror("Accept failed");
            continue;
        }

        pthread_t thread;
        pthread_create(&thread, NULL, handle_client, new_socket);
        pthread_detach(thread); // No need to join threads
    }

    close(server_fd);
    return 0;
}
-----------
multi_process_server.c
-------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

void handle_client(int new_socket) {
    char buffer[BUFFER_SIZE] = {0};
    int bytes_read = read(new_socket, buffer, BUFFER_SIZE);
    printf("Received: %s\n", buffer);
    send(new_socket, buffer, bytes_read, 0);
    close(new_socket);
}

int main() {
    int server_fd, new_socket;
    struct sockaddr_in address;
    int addrlen = sizeof(address);

    server_fd = socket(AF_INET, SOCK_STREAM, 0);
    bind(server_fd, (struct sockaddr *)&address, sizeof(address));
    listen(server_fd, 3);

    printf("Server with forked processes is listening on port %d...\n", PORT);

    while (1) {
        new_socket = accept(server_fd, (struct sockaddr *)&address, (socklen_t *)&addrlen);
        if (new_socket < 0) {
            perror("Accept failed");
            continue;
        }

        if (fork() == 0) { // Child process
            handle_client(new_socket);
            exit(0);
        } else { // Parent process
            close(new_socket);
        }
    }

    close(server_fd);
    return 0;
}
-----------------
15.Write a multi-threaded program to solve a unique problem which is figured out by you and solved by you.
--------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#define MAX_ARRAY_SIZE 1000
#define NUM_THREADS 4

// Global array to be sorted
int array[MAX_ARRAY_SIZE];
int n;  // Size of the array
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

// Function to sort a portion of the array (using quicksort)
void quicksort(int arr[], int low, int high) {
    if (low < high) {
        int pivot = arr[high];
        int i = (low - 1);
        for (int j = low; j < high; j++) {
            if (arr[j] <= pivot) {
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        int pi = i + 1;

        quicksort(arr, low, pi - 1);
        quicksort(arr, pi + 1, high);
    }
}

// Function to merge two sorted arrays
void merge(int arr[], int low, int mid, int high) {
    int n1 = mid - low + 1;
    int n2 = high - mid;
    int left[n1], right[n2];

    for (int i = 0; i < n1; i++) {
        left[i] = arr[low + i];
    }
    for (int i = 0; i < n2; i++) {
        right[i] = arr[mid + 1 + i];
    }

    int i = 0, j = 0, k = low;
    while (i < n1 && j < n2) {
        if (left[i] <= right[j]) {
            arr[k++] = left[i++];
        } else {
            arr[k++] = right[j++];
        }
    }

    while (i < n1) {
        arr[k++] = left[i++];
    }

    while (j < n2) {
        arr[k++] = right[j++];
    }
}

// Thread function to sort a portion of the array
void *sort_chunk(void *arg) {
    int chunk_id = *((int *)arg);
    int chunk_size = n / NUM_THREADS;
    int low = chunk_id * chunk_size;
    int high = (chunk_id == NUM_THREADS - 1) ? (n - 1) : (low + chunk_size - 1);

    // Sort the chunk using quicksort
    quicksort(array, low, high);

    pthread_exit(NULL);
}

// Function to merge all the sorted chunks
void merge_sorted_chunks() {
    int chunk_size = n / NUM_THREADS;
    for (int i = 0; i < NUM_THREADS - 1; i++) {
        int low = i * chunk_size;
        int mid = (i + 1) * chunk_size - 1;
        int high = (i == NUM_THREADS - 2) ? (n - 1) : (mid + chunk_size);

        merge(array, low, mid, high);
    }
}

int main() {
    // Initialize the array with random numbers
    printf("Enter the number of elements to sort (max 1000): ");
    scanf("%d", &n);

    if (n > MAX_ARRAY_SIZE) {
        printf("Number of elements exceeds maximum array size!\n");
        return 1;
    }

    printf("Enter %d integers:\n", n);
    for (int i = 0; i < n; i++) {
        scanf("%d", &array[i]);
    }

    // Create thread IDs and assign chunks to each thread
    pthread_t threads[NUM_THREADS];
    int chunk_ids[NUM_THREADS];

    // Create threads for sorting each chunk
    for (int i = 0; i < NUM_THREADS; i++) {
        chunk_ids[i] = i;
        pthread_create(&threads[i], NULL, sort_chunk, (void *)&chunk_ids[i]);
    }

    // Wait for all threads to finish sorting
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Merge the sorted chunks
    merge_sorted_chunks();

    // Print the sorted array
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");

    return 0;
}
-----------------------------------------
16.Check how multi-threading helps us to execute multiple processes at the same time. (a. Check global and local variable effect c. Check thread race problem)
------------------------------------------------------------------------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <pthread.h>

#define NUM_THREADS 2

// Global variables (shared by all threads)
int global_counter = 0;
pthread_mutex_t global_mutex = PTHREAD_MUTEX_INITIALIZER;

// Local variable for each thread
void* thread_func_with_local_var(void* arg) {
    int local_counter = 0;  // Local to each thread

    // Simulate some work by incrementing local_counter
    for (int i = 0; i < 5; i++) {
        local_counter++;
        printf("Thread %d: Local Counter = %d\n", *((int*)arg), local_counter);
    }

    pthread_exit(NULL);
}

// Function to demonstrate race condition with a global variable
void* thread_func_with_global_var(void* arg) {
    // Simulate some work by incrementing the global_counter
    for (int i = 0; i < 100000; i++) {
        global_counter++;
    }

    pthread_exit(NULL);
}

// Function to demonstrate thread-safe operation with a mutex
void* thread_func_with_mutex(void* arg) {
    // Simulate work using a mutex to protect the global_counter
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&global_mutex);
        global_counter++;
        pthread_mutex_unlock(&global_mutex);
    }

    pthread_exit(NULL);
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];
    
    // Example of threads working with local variables (no race condition)
    printf("Starting threads with local variables...\n");
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i + 1;
        pthread_create(&threads[i], NULL, thread_func_with_local_var, (void*)&thread_ids[i]);
    }

    // Wait for threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Demonstrate race condition with global variable
    global_counter = 0;  // Reset global counter
    printf("\nStarting threads with global variable (without mutex)...\n");
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i + 1;
        pthread_create(&threads[i], NULL, thread_func_with_global_var, (void*)&thread_ids[i]);
    }

    // Wait for threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Global counter after race condition (without mutex): %d\n", global_counter);

    // Demonstrate thread-safe operation with global variable (using mutex)
    global_counter = 0;  // Reset global counter
    printf("\nStarting threads with global variable (with mutex)...\n");
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i + 1;
        pthread_create(&threads[i], NULL, thread_func_with_mutex, (void*)&thread_ids[i]);
    }

    // Wait for threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    printf("Global counter after race condition (with mutex): %d\n", global_counter);

    return 0;
}
-----------------------------------------------------------------------------------------------------
17.Write a program to learn read() from keyboard file and write() into monitor file
------------------------------------------------------------------------------------------------------
#include <unistd.h>
#include <stdio.h>

int main() {
    char buffer[1024];  // Buffer to store input
    ssize_t bytes_read;

    // Prompt the user
    write(STDOUT_FILENO, "Enter text (Ctrl+D to end):\n", 28);

    // Read input from keyboard (standard input, file descriptor 0)
    while ((bytes_read = read(STDIN_FILENO, buffer, sizeof(buffer) - 1)) > 0) {
        // Write the input back to the monitor (standard output, file descriptor 1)
        write(STDOUT_FILENO, "You entered: ", 13);
        write(STDOUT_FILENO, buffer, bytes_read);
    }

    if (bytes_read == -1) {
        write(STDOUT_FILENO, "Error reading input.\n", 22);
        return 1;
    }

    write(STDOUT_FILENO, "\nEnd of Input.\n", 15);
    return 0;
}

--------------------------------------------------------------------------------------------------------
18.Write a program to read from a normal file/conventional file and display to monitor using open() read() write() system calls.
------------------------------------------------------------------------------------------------------------------------------------

#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <stdio.h>

int main() {
    // If O_APPEND is not specified, previous data will be overwritten
    int fd = open("task.txt", O_RDWR | O_CREAT |O_APPEND, 0666);
    if(fd == -1) {
        printf("Can't Open File.\n");
        return 1;
    }

    // Write
    char *msg = "1. Create a child process.\n";
    ssize_t bytes_written = write(fd, msg, strlen(msg));
    if(bytes_written == -1) {
        printf("Write Failed\n");
        close(fd);
        return 1;
    }

    lseek(fd, 0, SEEK_SET); // Move the file pointer at the beginning of the file

    // Read
    char buffer[1024];
    ssize_t bytes_read = read(fd, &buffer, sizeof(buffer));
    if(bytes_read == -1) {
        printf("Read Failed\n");
        close(fd);
        return 1;
    }
    buffer[bytes_read] = '\0';
    write(STDOUT_FILENO, buffer, strlen(buffer));
    close(fd);
}

--------------------------------------------------------------------------------------------------------------
19.Write a program to write a normal file/conventional file using open() read() write() system calls.
---------------------------------------------------------------------------------------------------------------
#include <fcntl.h>   // For open()
#include <unistd.h>  // For read(), write(), close()
#include <string.h>  // For strlen()
#include <stdio.h>   // For perror()

int main() {
    int fd;
    char buffer[1024];
    ssize_t bytes_read, bytes_written;

    // Open a file for writing (create it if it doesn't exist)
    fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("Error opening file");
        return 1;
    }

    // Prompt user for input
    write(STDOUT_FILENO, "Enter text to write to the file (Ctrl+D to end):\n", 48);

    // Read input from the user and write it to the file
    while ((bytes_read = read(STDIN_FILENO, buffer, sizeof(buffer))) > 0) {
        bytes_written = write(fd, buffer, bytes_read);
        if (bytes_written == -1) {
            perror("Error writing to file");
            close(fd);
            return 1;
        }
    }

    if (bytes_read == -1) {
        perror("Error reading input");
        close(fd);
        return 1;
    }

    // Close the file
    if (close(fd) == -1) {
        perror("Error closing file");
        return 1;
    }

    write(STDOUT_FILENO, "Data successfully written to 'output.txt'.\n", 43);
    return 0;
}


---------------------------------------------------
20.Write a program to create a named pipe using mkfifo() system call.
-----------------------------------------------------------------------------
Program 1: Create a Named Pipe and Write to It (Producer)
producer.c

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "myfifo"

int main() {
    int fd;
    const char* message = "Hello from the producer process!\n";

    // Create a named pipe (FIFO) if it doesn't exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("mkfifo failed");
        return 1;
    }

    // Open the FIFO for writing
    fd = open(PIPE_NAME, O_WRONLY);
    if (fd == -1) {
        perror("Failed to open FIFO for writing");
        return 1;
    }

    // Write a message to the FIFO
    write(fd, message, sizeof(message));

    // Close the FIFO
    close(fd);
    printf("Message written to the FIFO.\n");

    return 0;
}
------------------------------------------------------------------------
Program 2: Read from the Named Pipe (Consumer)
consumer.c
--------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

#define PIPE_NAME "myfifo"

int main() {
    int fd;
    char buffer[128];

    // Open the FIFO for reading
    fd = open(PIPE_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Failed to open FIFO for reading");
        return 1;
    }

    // Read the message from the FIFO
    read(fd, buffer, sizeof(buffer));

    // Print the message read from the FIFO
    printf("Message received from FIFO: %s", buffer);

    // Close the FIFO
    close(fd);

    return 0;
}
----------------------------------------------------------------------------------
21.Write a program to write in a named pipe what is read from the keyboard using open() read() write() system calls.
-----------------------------------------------------------------------------------------------------------------------
Program to Write to a Named Pipe from Keyboard (keyboard_to_pipe.c)

#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "myfifo"
#define MAX_BUFFER_SIZE 1024

int main() {
    int fd;
    char buffer[MAX_BUFFER_SIZE];
    ssize_t bytesRead, bytesWritten;

    // Create the named pipe (FIFO) if it doesn't exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("mkfifo failed");
        return 1;
    }

    printf("Enter text to write to the pipe: ");

    // Read from the keyboard (standard input)
    bytesRead = read(STDIN_FILENO, buffer, MAX_BUFFER_SIZE - 1);  // Read from keyboard input
    if (bytesRead == -1) {
        perror("Error reading from keyboard");
        return 1;
    }

    // Null-terminate the input string
    buffer[bytesRead] = '\0';

    // Open the FIFO for writing
    fd = open(PIPE_NAME, O_WRONLY);
    if (fd == -1) {
        perror("Error opening FIFO for writing");
        return 1;
    }

    // Write the data from the keyboard to the FIFO
    bytesWritten = write(fd, buffer, bytesRead);
    if (bytesWritten == -1) {
        perror("Error writing to FIFO");
        close(fd);
        return 1;
    }

    printf("Data written to the FIFO.\n");

    // Close the FIFO
    close(fd);

    return 0;
}
--------------------------------------------------------
Program to Read from the Named Pipe (pipe_to_output.c)
--------------------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

#define PIPE_NAME "myfifo"
#define MAX_BUFFER_SIZE 1024

int main() {
    int fd;
    char buffer[MAX_BUFFER_SIZE];
    ssize_t bytesRead;

    // Open the FIFO for reading
    fd = open(PIPE_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Error opening FIFO for reading");
        return 1;
    }

    // Read the data from the FIFO
    bytesRead = read(fd, buffer, MAX_BUFFER_SIZE - 1);
    if (bytesRead == -1) {
        perror("Error reading from FIFO");
        close(fd);
        return 1;
    }

    // Null-terminate the string and print it
    buffer[bytesRead] = '\0';
    printf("Data received from FIFO: %s", buffer);

    // Close the FIFO
    close(fd);

    return 0;
}
------------------------------------------------
22.Write a program to read from a named pipe and display to monitor using open() read() write() system calls.
-----------------------------------------------------------------------------------------------------------------
 Reading from a Named Pipe and Displaying to the Monitor
read_from_pipe.c
-----------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "myfifo"
#define MAX_BUFFER_SIZE 1024

int main() {
    int fd;
    char buffer[MAX_BUFFER_SIZE];
    ssize_t bytesRead;

    // Open the named pipe (FIFO) for reading
    fd = open(PIPE_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Error opening FIFO for reading");
        return 1;
    }

    // Read data from the FIFO (blocking operation if no data is written)
    bytesRead = read(fd, buffer, MAX_BUFFER_SIZE - 1);
    if (bytesRead == -1) {
        perror("Error reading from FIFO");
        close(fd);
        return 1;
    }

    // Null-terminate the string and display it on the monitor
    buffer[bytesRead] = '\0';
    printf("Data received from FIFO: %s", buffer);

    // Close the FIFO
    close(fd);

    return 0;
}
----------------
Write to the Named Pipe (write_to_pipe.c)
-----------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "myfifo"
#define MAX_BUFFER_SIZE 1024

int main() {
    int fd;
    char buffer[MAX_BUFFER_SIZE];

    // Create the FIFO if it doesn't exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("mkfifo failed");
        return 1;
    }

    printf("Enter data to write to the pipe: ");
    // Read input from the keyboard
    fgets(buffer, MAX_BUFFER_SIZE, stdin);

    // Open the FIFO for writing
    fd = open(PIPE_NAME, O_WRONLY);
    if (fd == -1) {
        perror("Error opening FIFO for writing");
        return 1;
    }

    // Write data to the FIFO
    write(fd, buffer, sizeof(buffer));

    // Close the FIFO
    close(fd);

    return 0;
}
-------------------------------------
23.Write a chat-room using a named pipe. (a. Start from one end and one by one message. b. Start from both ends and message simultaneously)
--------------------------------------------------------------------------------------------------------------------------------------------------
sender.c (Sender Process)
-------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "chatfifo"
#define MAX_MESSAGE_SIZE 1024

int main() {
    int fd;
    char message[MAX_MESSAGE_SIZE];

    // Create the named pipe (FIFO)
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("mkfifo failed");
        return 1;
    }

    while (1) {
        printf("Enter message to send: ");
        fgets(message, MAX_MESSAGE_SIZE, stdin);

        // Open the FIFO for writing
        fd = open(PIPE_NAME, O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO for writing");
            return 1;
        }

        // Write message to the FIFO
        write(fd, message, sizeof(message));

        // Close the FIFO
        close(fd);
    }

    return 0;
}
-------------------------------
receiver.c (Receiver Process)
--------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "chatfifo"
#define MAX_MESSAGE_SIZE 1024

int main() {
    int fd;
    char message[MAX_MESSAGE_SIZE];

    // Open the FIFO for reading
    fd = open(PIPE_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Error opening FIFO for reading");
        return 1;
    }

    while (1) {
        // Read message from the FIFO
        ssize_t bytesRead = read(fd, message, MAX_MESSAGE_SIZE - 1);
        if (bytesRead == -1) {
            perror("Error reading from FIFO");
            close(fd);
            return 1;
        }

        // Null-terminate and print the received message
        message[bytesRead] = '\0';
        printf("Received message: %s", message);
    }

    // Close the FIFO
    close(fd);

    return 0;
}
--------------------
chat.c (Bidirectional Chat)
--------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "chatfifo"
#define MAX_MESSAGE_SIZE 1024

// Thread to read messages from the pipe
void* read_messages(void* arg) {
    int fd;
    char message[MAX_MESSAGE_SIZE];

    // Open the FIFO for reading
    fd = open(PIPE_NAME, O_RDONLY);
    if (fd == -1) {
        perror("Error opening FIFO for reading");
        return NULL;
    }

    while (1) {
        ssize_t bytesRead = read(fd, message, MAX_MESSAGE_SIZE - 1);
        if (bytesRead == -1) {
            perror("Error reading from FIFO");
            close(fd);
            return NULL;
        }

        // Null-terminate and display the received message
        message[bytesRead] = '\0';
        printf("Received: %s", message);
    }

    close(fd);
    return NULL;
}

// Thread to send messages to the pipe
void* send_messages(void* arg) {
    int fd;
    char message[MAX_MESSAGE_SIZE];

    // Create the FIFO if it doesn't exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("mkfifo failed");
        return NULL;
    }

    while (1) {
        printf("Enter message to send: ");
        fgets(message, MAX_MESSAGE_SIZE, stdin);

        // Open the FIFO for writing
        fd = open(PIPE_NAME, O_WRONLY);
        if (fd == -1) {
            perror("Error opening FIFO for writing");
            return NULL;
        }

        // Write message to the FIFO
        write(fd, message, sizeof(message));

        // Close the FIFO
        close(fd);
    }

    return NULL;
}

int main() {
    pthread_t reader_thread, writer_thread;

    // Create a thread to handle reading messages
    if (pthread_create(&reader_thread, NULL, read_messages, NULL) != 0) {
        perror("Error creating reader thread");
        return 1;
    }

    // Create a thread to handle sending messages
    if (pthread_create(&writer_thread, NULL, send_messages, NULL) != 0) {
        perror("Error creating writer thread");
        return 1;
    }

    // Wait for threads to finish
    pthread_join(reader_thread, NULL);
    pthread_join(writer_thread, NULL);

    return 0;
}
--------------------------------
24.Investigate what would happened if you try to open a named pipe for reading multiple times.
-------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>

#define PIPE_NAME "myfifo"
#define MAX_BUFFER_SIZE 1024

int main() {
    int fd1, fd2;
    char buffer[MAX_BUFFER_SIZE];

    // Create the FIFO (named pipe) if it doesn't exist
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("Error creating FIFO");
        return 1;
    }

    // Open the FIFO for reading twice (simultaneously)
    fd1 = open(PIPE_NAME, O_RDONLY);
    if (fd1 == -1) {
        perror("Error opening FIFO for reading (fd1)");
        return 1;
    }
    printf("First file descriptor opened for reading.\n");

    // Simulate opening the FIFO again (second reader)
    fd2 = open(PIPE_NAME, O_RDONLY);
    if (fd2 == -1) {
        perror("Error opening FIFO for reading (fd2)");
        close(fd1);
        return 1;
    }
    printf("Second file descriptor opened for reading.\n");

    // Attempt to read from the FIFO
    ssize_t bytesRead = read(fd1, buffer, MAX_BUFFER_SIZE - 1); // Read from fd1
    if (bytesRead == -1) {
        perror("Error reading from FIFO (fd1)");
        close(fd1);
        close(fd2);
        return 1;
    }

    // Null terminate and display the message
    buffer[bytesRead] = '\0';
    printf("Read from first file descriptor (fd1): %s", buffer);

    // Close both file descriptors
    close(fd1);
    close(fd2);

    return 0;
}
----------------------------------------------------------------------------
25.Implement a unnamed pipe to send specific message (Say "Don't wait for me") from a child process to parent process to inform not to wait for the child process.
------------------------------------------------------------------------------------------------

#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <string.h>

#define MESSAGE "Don't wait for me"

int main() {
    int pipefds[2];   // File descriptors for the unnamed pipe
    pid_t pid;
    char buffer[100];

    // Create an unnamed pipe
    if (pipe(pipefds) == -1) {
        perror("pipe failed");
        return 1;
    }

    // Fork a child process
    pid = fork();
    if (pid == -1) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) {  // Child process
        // Close the read end of the pipe in the child process
        close(pipefds[0]);

        // Send the message to the parent through the pipe
        write(pipefds[1], MESSAGE, strlen(MESSAGE) + 1);

        // Close the write end of the pipe in the child process
        close(pipefds[1]);

        // Simulate some work done by the child process
        printf("Child: I am done, but don't wait for me.\n");

        // Exit the child process
        _exit(0);
    } else {  // Parent process
        // Close the write end of the pipe in the parent process
        close(pipefds[1]);

        // Read the message from the pipe
        read(pipefds[0], buffer, sizeof(buffer));
        
        // Print the message received from the child
        printf("Parent: Received message - %s\n", buffer);

        // Close the read end of the pipe in the parent process
        close(pipefds[0]);

        // The parent doesn't need to wait for the child based on the message
        printf("Parent: I will not wait for the child to finish.\n");

        // Parent does not wait for the child process
        // Parent process exits immediately
        _exit(0);
    }

    return 0;
}
----------------------------------------------------------------
26)Investigate if two separate process try to read a named pipe first and then write to the pipe
------------------------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <string.h>
#include <stdlib.h>

#define PIPE_NAME "myfifo"
#define MESSAGE "Hello from the writer process!"

int main() {
    pid_t pid;
    int pipefd;
    char buffer[1024];

    // Create the named pipe (FIFO)
    if (mkfifo(PIPE_NAME, 0666) == -1) {
        perror("Error creating FIFO");
        return 1;
    }

    pid = fork();  // Create a child process

    if (pid == -1) {
        perror("fork failed");
        return 1;
    }

    if (pid == 0) {  // Child process (Writer)
        // Open the named pipe for writing
        pipefd = open(PIPE_NAME, O_WRONLY);
        if (pipefd == -1) {
            perror("Error opening FIFO for writing");
            return 1;
        }

        // Write a message to the pipe
        printf("Child (Writer): Writing to the pipe...\n");
        write(pipefd, MESSAGE, strlen(MESSAGE) + 1);  // Include the null terminator

        // Close the write end of the pipe
        close(pipefd);
        printf("Child (Writer): Data written to the pipe.\n");
    } else {  // Parent process (Reader)
        // Open the named pipe for reading
        pipefd = open(PIPE_NAME, O_RDONLY);
        if (pipefd == -1) {
            perror("Error opening FIFO for reading");
            return 1;
        }

        // Read from the pipe
        printf("Parent (Reader): Waiting for data...\n");
        ssize_t bytesRead = read(pipefd, buffer, sizeof(buffer) - 1);
        if (bytesRead == -1) {
            perror("Error reading from FIFO");
            return 1;
        }

        // Null-terminate and print the received message
        buffer[bytesRead] = '\0';
        printf("Parent (Reader): Received message: %s\n", buffer);

        // Close the read end of the pipe
        close(pipefd);
    }

    // Remove the named pipe
    unlink(PIPE_NAME);

    return 0;
}
---------------------------------
27.Investigate when race condition occurs in a multi-threaded program
-------------------------------------------------------------------------
#include <stdio.h>
#include <pthread.h>

int counter = 0; // Shared resource

void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        counter++; // Increment the counter
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    // Create two threads
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    
    // Wait for both threads to finish
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // The expected result is 200000 (100000 * 2)
    printf("Final counter value: %d\n", counter);
    return 0;
}
--------------------------------------------------------
28.Find a solution to avoid race condition in a multi-threaded program.
--------------------------------------------------------------------------
Example of Using Mutex to Prevent Race Condition:
----------------------------------------------------
#include <stdio.h>
#include <pthread.h>

int counter = 0; // Shared resource
pthread_mutex_t counter_mutex; // Mutex to protect the counter

// Function to increment the counter
void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        pthread_mutex_lock(&counter_mutex);  // Lock the mutex
        counter++; // Increment the counter
        pthread_mutex_unlock(&counter_mutex);  // Unlock the mutex
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    // Initialize the mutex
    pthread_mutex_init(&counter_mutex, NULL);

    // Create two threads
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    
    // Wait for both threads to finish
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // The expected result is 200000 (100000 * 2)
    printf("Final counter value: %d\n", counter);
    
    // Destroy the mutex
    pthread_mutex_destroy(&counter_mutex);
    
    return 0;
}
-----------------------
Example of Using Semaphore:
--------------------------------
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

int counter = 0; // Shared resource
sem_t sem; // Semaphore for synchronization

// Function to increment the counter
void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        sem_wait(&sem); // Wait (decrement) the semaphore
        counter++; // Increment the counter
        sem_post(&sem); // Signal (increment) the semaphore
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    // Initialize the semaphore to 1 (binary semaphore, like a mutex)
    sem_init(&sem, 0, 1);

    // Create two threads
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    
    // Wait for both threads to finish
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // The expected result is 200000 (100000 * 2)
    printf("Final counter value: %d\n", counter);
    
    // Destroy the semaphore
    sem_destroy(&sem);
    
    return 0;
}
------------------------------
Example of Atomic Increment (Using __atomic in GCC):
---------------------------------------------------------
#include <stdio.h>
#include <pthread.h>

int counter = 0; // Shared resource

// Function to increment the counter atomically
void* increment(void* arg) {
    for (int i = 0; i < 100000; i++) {
        __atomic_fetch_add(&counter, 1, __ATOMIC_SEQ_CST); // Atomic increment
    }
    return NULL;
}

int main() {
    pthread_t t1, t2;
    
    // Create two threads
    pthread_create(&t1, NULL, increment, NULL);
    pthread_create(&t2, NULL, increment, NULL);
    
    // Wait for both threads to finish
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    // The expected result is 200000 (100000 * 2)
    printf("Final counter value: %d\n", counter);
    
    return 0;
}
---------------------------------------------------------
29.Check how many core you have in your system. Create 4 more process than your core and use a for loop to understand how os schedule the process in different core. Each core should have three thread. Use get_cpu() to read the assigned core and set_cpu() to set the core for each thread.
------------------------------------------------------------------------------------------------------------------------------
#define _GNU_SOURCE
#include <stdio.h>
#include <pthread.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>
#include <sys/sysctl.h>
#include <sys/types.h>

int num_cores;  // To store the number of cores
int num_processes; // Number of processes to create

// Function to get the number of CPU cores
int get_num_cores() {
    // Linux or Unix-like systems: using sysctl
    return sysconf(_SC_NPROCESSORS_ONLN);
}

// Function to get the CPU core the thread is currently running on
void get_cpu() {
    cpu_set_t cpuset;
    int cpu;

    pthread_t current_thread = pthread_self();
    pthread_getaffinity_np(current_thread, sizeof(cpu_set_t), &cpuset);

    // Find the CPU the thread is running on
    for (cpu = 0; cpu < num_cores; cpu++) {
        if (CPU_ISSET(cpu, &cpuset)) {
            printf("Thread is running on core: %d\n", cpu);
            return;
        }
    }
}

// Function to set the CPU affinity for the current thread
void set_cpu(int core_id) {
    cpu_set_t cpuset;

    CPU_ZERO(&cpuset);
    CPU_SET(core_id, &cpuset);

    // Set the CPU affinity of the current thread
    int result = pthread_setaffinity_np(pthread_self(), sizeof(cpu_set_t), &cpuset);
    if (result != 0) {
        perror("Error setting CPU affinity");
        exit(EXIT_FAILURE);
    }
}

// Thread function
void* thread_function(void* arg) {
    int thread_num = *((int*)arg);
    int core_id = thread_num % num_cores;  // Distribute threads across available cores

    set_cpu(core_id);  // Set the thread to the designated core
    get_cpu();  // Check which core it has been set to

    printf("Thread %d started on core %d\n", thread_num, core_id);
    return NULL;
}

// Process function
void* process_function(void* arg) {
    int process_num = *((int*)arg);
    pthread_t threads[3];
    int thread_nums[3];

    printf("Process %d started\n", process_num);

    // Create 3 threads for each process
    for (int i = 0; i < 3; i++) {
        thread_nums[i] = process_num * 3 + i;  // Assign unique thread numbers
        pthread_create(&threads[i], NULL, thread_function, &thread_nums[i]);
    }

    // Wait for all threads to finish
    for (int i = 0; i < 3; i++) {
        pthread_join(threads[i], NULL);
    }

    return NULL;
}

int main() {
    num_cores = get_num_cores();  // Get the number of CPU cores
    num_processes = num_cores + 4;  // Create 4 more processes than the number of cores

    printf("System has %d CPU cores\n", num_cores);

    pthread_t processes[num_processes];

    // Create processes and assign threads to cores
    for (int i = 0; i < num_processes; i++) {
        pthread_create(&processes[i], NULL, process_function, &i);
    }

    // Wait for all processes to finish
    for (int i = 0; i < num_processes; i++) {
        pthread_join(processes[i], NULL);
    }

    return 0;
}
------------------------------------------------------------
30)If we lock the thread twice, without unlocking it, what would happen? Investigate it
------------------------------------------------------------------------------------------------
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void* thread_function(void* arg) {
    printf("Thread is attempting to lock the mutex...\n");
    
    pthread_mutex_lock(&mutex);  // First lock
    printf("Thread has locked the mutex.\n");
    
    // Attempting to lock the mutex again without unlocking it
    pthread_mutex_lock(&mutex);  // Second lock, this causes deadlock

    printf("This line will never be printed.\n");

    pthread_mutex_unlock(&mutex);  // Unlocking the mutex (won't reach here)
    return NULL;
}

int main() {
    pthread_t thread;

    // Create a thread
    pthread_create(&thread, NULL, thread_function, NULL);

    // Wait for the thread to finish
    pthread_join(thread, NULL);

    return 0;
}
----------------------------------------------------------------
31.If you have two thread and you use two mutex for each thread, what would happen for each combination? Investigate it. Example:
mutex_lock(key1)
mutex_lock(key2)
##-- Critical Section --##
mutex_lock(key1)
mutex_lock(key2)
-----------------------------------------------------------------------------
#include <stdio.h>
#include <pthread.h>
#include <unistd.h>

pthread_mutex_t key1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t key2 = PTHREAD_MUTEX_INITIALIZER;

void* thread_function1(void* arg) {
    pthread_mutex_lock(&key1);  // Lock key1
    printf("Thread 1 locked key1\n");

    sleep(1);  // Sleep to simulate some work

    pthread_mutex_lock(&key2);  // Lock key2
    printf("Thread 1 locked key2\n");

    // Critical Section
    printf("Thread 1 in critical section\n");

    pthread_mutex_unlock(&key2);
    pthread_mutex_unlock(&key1);

    return NULL;
}

void* thread_function2(void* arg) {
    pthread_mutex_lock(&key2);  // Lock key2
    printf("Thread 2 locked key2\n");

    sleep(1);  // Sleep to simulate some work

    pthread_mutex_lock(&key1);  // Lock key1
    printf("Thread 2 locked key1\n");

    // Critical Section
    printf("Thread 2 in critical section\n");

    pthread_mutex_unlock(&key1);
    pthread_mutex_unlock(&key2);

    return NULL;
}

int main() {
    pthread_t t1, t2;

    pthread_create(&t1, NULL, thread_function1, NULL);
    pthread_create(&t2, NULL, thread_function2, NULL);

    pthread_join(t1, NULL);
    pthread_join(t2, NULL);

    return 0;
}
--------------------------------------------------------
32.Inter-Process Communication (Shared Memory)
----------------------------------------------------------
Producer Code (Writes Data to Shared Memory)
--------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>
#include <unistd.h>

#define SHM_SIZE 1024 // Shared memory size

int main() {
    key_t key = ftok("shmfile", 65); // Generate a unique key
    int shmid = shmget(key, SHM_SIZE, 0666|IPC_CREAT); // Create shared memory segment

    if (shmid == -1) {
        perror("shmget failed");
        exit(1);
    }

    // Attach to the shared memory
    char *data = (char*) shmat(shmid, NULL, 0);

    if (data == (char *) -1) {
        perror("shmat failed");
        exit(1);
    }

    printf("Producer: Enter data to be written into shared memory: ");
    fgets(data, SHM_SIZE, stdin); // Read input from user and write to shared memory

    printf("Producer: Data written to shared memory: %s\n", data);

    // Detach from shared memory
    shmdt(data);

    return 0;
}
-------------------------------------------------------------
Consumer Code (Reads Data from Shared Memory)
--------------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>

#define SHM_SIZE 1024 // Shared memory size

int main() {
    key_t key = ftok("shmfile", 65); // Generate a unique key
    int shmid = shmget(key, SHM_SIZE, 0666|IPC_CREAT); // Get shared memory segment ID

    if (shmid == -1) {
        perror("shmget failed");
        exit(1);
    }

    // Attach to the shared memory
    char *data = (char*) shmat(shmid, NULL, 0);

    if (data == (char *) -1) {
        perror("shmat failed");
        exit(1);
    }

    printf("Consumer: Data read from shared memory: %s\n", data);

    // Detach from shared memory
    shmdt(data);

    // Optionally remove the shared memory segment
    shmctl(shmid, IPC_RMID, NULL);

    return 0;
}
---------------------------
33.Signal
--------------------------------
Signal Handler Example
In this example, a signal handler is registered to catch the SIGINT signal (which is sent when the user presses Ctrl+C).
----------------------------
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int sig) {
    if (sig == SIGINT) {
        printf("\nCaught SIGINT (Ctrl+C). Program will exit.\n");
        exit(0);  // Exit the program
    }
}

int main() {
    // Register the signal handler for SIGINT (Ctrl+C)
    if (signal(SIGINT, signal_handler) == SIG_ERR) {
        perror("signal");
        exit(1);
    }

    printf("Program is running. Press Ctrl+C to send SIGINT...\n");

    // Simulate a long-running process
    while (1) {
        sleep(1);
    }

    return 0;
}
----------------------------
Signal Handling Using sigaction()
---------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void signal_handler(int sig) {
    if (sig == SIGINT) {
        printf("\nCaught SIGINT (Ctrl+C). Program will exit.\n");
        exit(0);
    }
}

int main() {
    struct sigaction sa;

    // Set up the signal handler
    sa.sa_handler = signal_handler;
    sa.sa_flags = 0;  // No special flags
    sigemptyset(&sa.sa_mask);  // No additional signals to block during handling

    // Register the signal handler for SIGINT
    if (sigaction(SIGINT, &sa, NULL) == -1) {
        perror("sigaction");
        exit(1);
    }

    printf("Program is running. Press Ctrl+C to send SIGINT...\n");

    // Simulate a long-running process
    while (1) {
        sleep(1);
    }

    return 0;
}
----------------------------
34.Stack Smashing
----------------------------
Consider the following C program where a buffer overflow can lead to stack smashing:
-------------------------------------------------------------------------------------
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[10];
    strcpy(buffer, input);  // No bounds checking, vulnerable to overflow
}

int main() {
    char *input = "A very long string";  // Input exceeds buffer size
    vulnerable_function(input);
    printf("Program finished\n");
    return 0;
}
-----------------------------------------------
36.Create server-client model for communication using socket programming in C.
--------------------------------------------------------------------------------
Server Code (server.c):
-----------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    char buffer[BUFFER_SIZE];
    int n;

    // Create socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind socket to address and port
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, MAX_CLIENTS) == -1) {
        perror("Listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // Accept incoming client connection
    client_len = sizeof(client_addr);
    if ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_len)) == -1) {
        perror("Accept failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Client connected: %s\n", inet_ntoa(client_addr.sin_addr));

    // Receive message from client
    n = recv(client_fd, buffer, BUFFER_SIZE, 0);
    if (n == -1) {
        perror("Receive failed");
        close(client_fd);
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    buffer[n] = '\0';  // Null-terminate the received string
    printf("Client says: %s\n", buffer);

    // Send response to client
    const char *response = "Message received!";
    if (send(client_fd, response, strlen(response), 0) == -1) {
        perror("Send failed");
        close(client_fd);
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Close the sockets
    close(client_fd);
    close(server_fd);

    return 0;
}
------------------------
Client Code (client.c):
-----------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int sock_fd;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    const char *message = "Hello, Server!";

    // Create socket
    if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  // Localhost

    // Connect to server
    if (connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Connection failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    printf("Connected to server\n");

    // Send message to server
    if (send(sock_fd, message, strlen(message), 0) == -1) {
        perror("Send failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // Receive response from server
    int n = recv(sock_fd, buffer, BUFFER_SIZE, 0);
    if (n == -1) {
        perror("Receive failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    buffer[n] = '\0';  // Null-terminate the received string
    printf("Server says: %s\n", buffer);

    // Close the socket
    close(sock_fd);

    return 0;
}
--------------------------------------
37.Create server-client model for multi-client communication using socket programming in C.
---------------------------------------
Server Code (server.c):
-------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

// Structure to hold client information (socket descriptor)
typedef struct {
    int client_fd;
    struct sockaddr_in client_addr;
} client_info;

// Function to handle communication with the client
void *handle_client(void *arg) {
    client_info *cli = (client_info *)arg;
    char buffer[BUFFER_SIZE];
    int n;

    // Receive message from client
    n = recv(cli->client_fd, buffer, BUFFER_SIZE, 0);
    if (n == -1) {
        perror("Receive failed");
        close(cli->client_fd);
        free(cli);
        pthread_exit(NULL);
    }

    buffer[n] = '\0';  // Null-terminate the received string
    printf("Client (%s:%d) says: %s\n", inet_ntoa(cli->client_addr.sin_addr), ntohs(cli->client_addr.sin_port), buffer);

    // Send response to client
    const char *response = "Message received!";
    if (send(cli->client_fd, response, strlen(response), 0) == -1) {
        perror("Send failed");
        close(cli->client_fd);
        free(cli);
        pthread_exit(NULL);
    }

    // Close the client socket and free memory
    close(cli->client_fd);
    free(cli);
    pthread_exit(NULL);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    pthread_t thread_id;

    // Create socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind socket to address and port
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, MAX_CLIENTS) == -1) {
        perror("Listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // Accept incoming client connections in a loop
    while (1) {
        client_len = sizeof(client_addr);
        if ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_len)) == -1) {
            perror("Accept failed");
            continue;
        }

        printf("Client connected: %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        // Allocate memory for client information and initialize it
        client_info *cli = (client_info *)malloc(sizeof(client_info));
        cli->client_fd = client_fd;
        cli->client_addr = client_addr;

        // Create a new thread to handle the client
        if (pthread_create(&thread_id, NULL, handle_client, (void *)cli) != 0) {
            perror("Thread creation failed");
            close(client_fd);
            free(cli);
        }

        // Detach the thread to free resources automatically when it finishes
        pthread_detach(thread_id);
    }

    // Close the server socket (this will never be reached in this example)
    close(server_fd);

    return 0;
}
--------------------------------------------
Client Code (client.c):
------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int sock_fd;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    const char *message = "Hello, Server!";

    // Create socket
    if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  // Localhost

    // Connect to server
    if (connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Connection failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    printf("Connected to server\n");

    // Send message to server
    if (send(sock_fd, message, strlen(message), 0) == -1) {
        perror("Send failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // Receive response from server
    int n = recv(sock_fd, buffer, BUFFER_SIZE, 0);
    if (n == -1) {
        perror("Receive failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    buffer[n] = '\0';  // Null-terminate the received string
    printf("Server says: %s\n", buffer);

    // Close the socket
    close(sock_fd);

    return 0;
}
------------------------------------------
38) Create server-client model for multi-client communication using socket programming and multi-threading in C
-----------------------------------------------------------------------------------------------------------------
Server Code (server.c)
----------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <pthread.h>

#define PORT 8080
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024

// Structure to hold client information (socket descriptor)
typedef struct {
    int client_fd;
    struct sockaddr_in client_addr;
} client_info;

// Function to handle communication with the client
void *handle_client(void *arg) {
    client_info *cli = (client_info *)arg;
    char buffer[BUFFER_SIZE];
    int n;

    // Receive message from client
    n = recv(cli->client_fd, buffer, BUFFER_SIZE, 0);
    if (n == -1) {
        perror("Receive failed");
        close(cli->client_fd);
        free(cli);
        pthread_exit(NULL);
    }

    buffer[n] = '\0';  // Null-terminate the received string
    printf("Client (%s:%d) says: %s\n", inet_ntoa(cli->client_addr.sin_addr), ntohs(cli->client_addr.sin_port), buffer);

    // Send response to client
    const char *response = "Message received!";
    if (send(cli->client_fd, response, strlen(response), 0) == -1) {
        perror("Send failed");
        close(cli->client_fd);
        free(cli);
        pthread_exit(NULL);
    }

    // Close the client socket and free memory
    close(cli->client_fd);
    free(cli);
    pthread_exit(NULL);
}

int main() {
    int server_fd, client_fd;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len;
    pthread_t thread_id;

    // Create socket
    if ((server_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(PORT);

    // Bind socket to address and port
    if (bind(server_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Bind failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    // Listen for incoming connections
    if (listen(server_fd, MAX_CLIENTS) == -1) {
        perror("Listen failed");
        close(server_fd);
        exit(EXIT_FAILURE);
    }

    printf("Server listening on port %d...\n", PORT);

    // Accept incoming client connections in a loop
    while (1) {
        client_len = sizeof(client_addr);
        if ((client_fd = accept(server_fd, (struct sockaddr *)&client_addr, &client_len)) == -1) {
            perror("Accept failed");
            continue;
        }

        printf("Client connected: %s:%d\n", inet_ntoa(client_addr.sin_addr), ntohs(client_addr.sin_port));

        // Allocate memory for client information and initialize it
        client_info *cli = (client_info *)malloc(sizeof(client_info));
        cli->client_fd = client_fd;
        cli->client_addr = client_addr;

        // Create a new thread to handle the client
        if (pthread_create(&thread_id, NULL, handle_client, (void *)cli) != 0) {
            perror("Thread creation failed");
            close(client_fd);
            free(cli);
        }

        // Detach the thread to free resources automatically when it finishes
        pthread_detach(thread_id);
    }

    // Close the server socket (this will never be reached in this example)
    close(server_fd);

    return 0;
}
-----------------------------------
Client Code (client.c)
---------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

#define PORT 8080
#define BUFFER_SIZE 1024

int main() {
    int sock_fd;
    struct sockaddr_in server_addr;
    char buffer[BUFFER_SIZE];
    const char *message = "Hello, Server!";

    // Create socket
    if ((sock_fd = socket(AF_INET, SOCK_STREAM, 0)) == -1) {
        perror("Socket creation failed");
        exit(EXIT_FAILURE);
    }

    // Set server address
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(PORT);
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");  // Localhost

    // Connect to server
    if (connect(sock_fd, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
        perror("Connection failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    printf("Connected to server\n");

    // Send message to server
    if (send(sock_fd, message, strlen(message), 0) == -1) {
        perror("Send failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    // Receive response from server
    int n = recv(sock_fd, buffer, BUFFER_SIZE, 0);
    if (n == -1) {
        perror("Receive failed");
        close(sock_fd);
        exit(EXIT_FAILURE);
    }

    buffer[n] = '\0';  // Null-terminate the received string
    printf("Server says: %s\n", buffer);

    // Close the socket
    close(sock_fd);

    return 0;
}





